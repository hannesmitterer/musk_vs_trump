<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Musk vs Trump Dashboard</title>
  <meta name="description" content="Live dashboard with 3D graph and progressive background.">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,700&display=swap" rel="stylesheet">
  <style>
    html, body {
      height: 100%;
      margin: 0;
      padding: 0;
      font-family: 'Roboto', Arial, sans-serif;
      overflow: hidden;
      background: linear-gradient(120deg, #0f2027, #2c5364, #1c92d2);
      transition: background 1s cubic-bezier(.68,-0.55,.27,1.55);
    }
    body.bg-transition {
      background: linear-gradient(120deg, #16222A, #3A6073, #1c92d2 80%);
    }
    #background-canvas {
      position: fixed;
      top: 0; left: 0;
      width: 100vw; height: 100vh;
      z-index: 0;
      pointer-events: none;
    }
    .container {
      position: relative;
      z-index: 1;
      width: 100vw;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2vh 2vw;
      color: #fff;
      overflow-y: auto;
    }
    .title {
      font-size: clamp(2rem, 6vw, 4rem);
      font-weight: 700;
      margin-bottom: 1vh;
      text-align: center;
      text-shadow: 0 2px 12px #000a;
      letter-spacing: .08em;
    }
    .desc {
      font-size: clamp(1rem, 3vw, 1.5rem);
      margin-bottom: 3vh;
      text-align: center;
      text-shadow: 0 1px 6px #0007;
      max-width: 90vw;
    }
    .dashboard-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 3vw;
      width: 96vw;
      max-width: 1400px;
      margin-bottom: 3vh;
    }
    .panel {
      background: rgba(255,255,255,0.1);
      backdrop-filter: blur(15px);
      border-radius: 1.5em;
      padding: 2rem;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      border: 1px solid rgba(255,255,255,0.2);
    }
    .panel h3 {
      font-size: 1.5rem;
      margin-bottom: 1.5rem;
      text-align: center;
      color: #fff;
      font-weight: 600;
    }
    #three-root {
      width: 96vw;
      max-width: 1400px;
      height: 55vh;
      border-radius: 2em;
      overflow: hidden;
      box-shadow: 0 2px 32px #0008;
      background: rgba(0,0,0,0.15);
      margin-bottom: 3vh;
      touch-action: manipulation;
    }
    .sources-list {
      list-style: none;
      padding: 0;
    }
    .sources-list li {
      background: rgba(255,255,255,0.1);
      margin-bottom: 0.8rem;
      padding: 1rem 1.2rem;
      border-radius: 0.8rem;
      border-left: 4px solid #00eaff;
      transition: all 0.3s ease;
    }
    .sources-list li:hover {
      background: rgba(255,255,255,0.2);
      transform: translateX(5px);
    }
    .source-name {
      font-weight: 600;
      font-size: 1.1rem;
      margin-bottom: 0.3rem;
    }
    .source-details {
      font-size: 0.9rem;
      opacity: 0.8;
    }
    .summary-chart {
      height: 300px;
      position: relative;
    }
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 1rem;
      margin-top: 1.5rem;
    }
    .stat-item {
      text-align: center;
      background: rgba(255,255,255,0.1);
      padding: 1rem;
      border-radius: 0.8rem;
    }
    .stat-value {
      font-size: 1.8rem;
      font-weight: bold;
      color: #00eaff;
    }
    .stat-label {
      font-size: 0.9rem;
      opacity: 0.8;
      margin-top: 0.3rem;
    }
    @media (max-width: 768px) {
      .dashboard-grid {
        grid-template-columns: 1fr;
        gap: 2vh;
      }
      #three-root { height: 38vh; }
      .container { padding: 1vh 1vw; }
      .panel { padding: 1.5rem; }
    }
    
    /* Loading and performance enhancements */
    .loaded #three-root {
      animation: fadeInUp 0.8s ease-out;
    }
    
    .loaded .panel {
      animation: fadeInUp 0.8s ease-out;
      animation-delay: 0.2s;
      animation-fill-mode: both;
    }
    
    @keyframes fadeInUp {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }
    
    /* Performance: Reduced motion for users who prefer it */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    }
    
    /* High contrast mode support */
    @media (prefers-contrast: high) {
      .panel {
        border: 2px solid #fff;
        background: rgba(0, 0, 0, 0.8);
      }
      
      .sources-list li {
        border-left-width: 6px;
      }
    }
  </style>
</head>
<body>
  <canvas id="background-canvas"></canvas>
  <div class="container">
    <div class="title">Musk vs Trump</div>
    <div class="desc">Enhanced AI Reputation Tracker with real-time monitoring and comprehensive analytics</div>
    
    <!-- 3D Visualization -->
    <div id="three-root"></div>
    
    <!-- Dashboard Grid -->
    <div class="dashboard-grid">
      <!-- AI Tracking Sources Panel -->
      <div class="panel">
        <h3>üîç AI Tracking Sources</h3>
        <ul class="sources-list" id="sourcesList">
          <li>
            <div class="source-name">API Endpoints</div>
            <div class="source-details">Real-time reputation data from /api/reputation</div>
          </li>
          <li>
            <div class="source-name">Database Tables</div>
            <div class="source-details">Historical sentiment and metrics storage</div>
          </li>
          <li>
            <div class="source-name">Event Logs</div>
            <div class="source-details">Tracking system events and updates</div>
          </li>
          <li>
            <div class="source-name">Social Media Feeds</div>
            <div class="source-details">Twitter, Reddit, News aggregation</div>
          </li>
          <li>
            <div class="source-name">AI Sentiment Engine</div>
            <div class="source-details">NLP analysis and score computation</div>
          </li>
        </ul>
      </div>
      
      <!-- Cumulative Summary Panel -->
      <div class="panel">
        <h3>üìä Cumulative Summary Since Start</h3>
        <div class="summary-chart">
          <canvas id="summaryChart"></canvas>
        </div>
        <div class="stats-grid">
          <div class="stat-item">
            <div class="stat-value" id="totalDataPoints">2,847</div>
            <div class="stat-label">Data Points</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="avgMuskScore">72.3</div>
            <div class="stat-label">Avg Musk Score</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="avgTrumpScore">65.8</div>
            <div class="stat-label">Avg Trump Score</div>
          </div>
          <div class="stat-item">
            <div class="stat-value" id="uptime">99.7%</div>
            <div class="stat-label">System Uptime</div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <!-- Fallback for offline environments -->
  <script>
    // Performance optimization: Lazy load external libraries
    function loadScript(src, callback) {
      const script = document.createElement('script');
      script.src = src;
      script.onload = callback;
      script.onerror = () => {
        console.log(`Failed to load ${src}, using fallback`);
        if (callback) callback();
      };
      document.head.appendChild(script);
    }
    
    // Load THREE.js
    loadScript('https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js', () => {
      console.log('THREE.js loaded successfully');
    });
    
    // Load Chart.js
    loadScript('https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.min.js', () => {
      console.log('Chart.js loaded successfully');
    });
  </script>
  <!-- Simple 3D Live Graph -->
  <script>
    // Progressive Background Animation
    const bgCanvas = document.getElementById('background-canvas');
    let bgCtx = bgCanvas.getContext('2d');
    function resizeBg() {
      bgCanvas.width = window.innerWidth;
      bgCanvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeBg);
    resizeBg();
    let bgTime = 0;
    function drawBg() {
      bgTime += 0.008;
      let w = bgCanvas.width, h = bgCanvas.height;
      bgCtx.clearRect(0,0,w,h);
      for (let i=0; i<5; i++) {
        let x = w/2 + Math.sin(bgTime+i)*w/3;
        let y = h/2 + Math.cos(bgTime-i)*h/3;
        let r = 180 + Math.sin(bgTime+i)*60;
        let grad = bgCtx.createRadialGradient(x, y, 0, x, y, r);
        grad.addColorStop(0, `rgba(${60+40*i},${120+30*i},${255-12*i},0.13)`);
        grad.addColorStop(1, 'rgba(30,30,40,0)');
        bgCtx.beginPath();
        bgCtx.arc(x, y, r, 0, 2*Math.PI);
        bgCtx.fillStyle = grad;
        bgCtx.fill();
      }
      requestAnimationFrame(drawBg);
    }
    drawBg();

    // 3D Graph with fallback
    function init3DGraph() {
      const threeRoot = document.getElementById('three-root');
      
      if (typeof THREE === 'undefined') {
        // Fallback: Create a simple 2D canvas visualization
        console.log('THREE.js not available, using 2D fallback');
        createFallback3D(threeRoot);
        return;
      }
      
      let width = threeRoot.clientWidth, height = threeRoot.clientHeight;
      let scene = new THREE.Scene();
      scene.background = null;
      let camera = new THREE.PerspectiveCamera(60, width/height, 0.1, 1000);
      camera.position.set(0, 0, 35);

      let renderer = new THREE.WebGLRenderer({alpha:true, antialias:true});
      renderer.setSize(width, height);
      threeRoot.appendChild(renderer.domElement);

      // Graph Data
      function randomData(n, min, max) {
        return Array(n).fill().map((_,i)=>({x:i, y:min+Math.random()*(max-min)}));
      }
      let graphData = randomData(24, 2, 28);

      // 3D Graph Construction
      let graphGroup = new THREE.Group();
      let lineMat = new THREE.LineBasicMaterial({color:0x00eaff, linewidth:2});
      let points = graphData.map((d,i) => new THREE.Vector3(i-12, d.y-15, Math.sin(i*0.18)*4));
      let geometry = new THREE.BufferGeometry().setFromPoints(points);
      let line = new THREE.Line(geometry, lineMat);
      graphGroup.add(line);

      // Data points (spheres)
      let sphereGeo = new THREE.SphereGeometry(0.45, 16, 16);
      graphData.forEach((d,i) => {
        let color = i === graphData.length-1 ? 0xff3b3b : 0x00eaff;
        let mat = new THREE.MeshStandardMaterial({color, emissive:0x333333, metalness:0.6, roughness:0.25});
        let mesh = new THREE.Mesh(sphereGeo, mat);
        mesh.position.set(i-12, d.y-15, Math.sin(i*0.18)*4);
        graphGroup.add(mesh);
      });

      // Axes
      let axesMat = new THREE.LineBasicMaterial({color:0xffffff, linewidth:1, opacity:0.5, transparent:true});
      let axesGeo = new THREE.BufferGeometry().setFromPoints([
        new THREE.Vector3(-12,-14,0), new THREE.Vector3(12,-14,0), // X
        new THREE.Vector3(-12,-14,0), new THREE.Vector3(-12,13,0) // Y
      ]);
      let axes = new THREE.LineSegments(axesGeo, axesMat);
      graphGroup.add(axes);

      scene.add(graphGroup);

      // Lighting
      let amb = new THREE.AmbientLight(0xcccccc, .8);
      scene.add(amb);
      let dir = new THREE.DirectionalLight(0xffffff, 1);
      dir.position.set(0,20,20);
      scene.add(dir);

      // Responsive Resize
      function onResize() {
        width = threeRoot.clientWidth;
        height = threeRoot.clientHeight;
        camera.aspect = width/height;
        camera.updateProjectionMatrix();
        renderer.setSize(width, height);
      }
      window.addEventListener('resize', onResize);

      // Animation Loop
      let angle = 0;
      function animate() {
        angle += 0.004;
        graphGroup.rotation.y = Math.sin(angle)*0.12;
        graphGroup.rotation.x = Math.cos(angle)*0.08;
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      animate();

      // Touch/Drag Interaction
      let lastX = null, lastY = null;
      let dragging = false;
      threeRoot.addEventListener('pointerdown', (e) => {
        dragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
      });
      window.addEventListener('pointerup', ()=>dragging=false);
      window.addEventListener('pointermove', (e) => {
        if (!dragging) return;
        let dx = e.clientX - lastX;
        let dy = e.clientY - lastY;
        graphGroup.rotation.y += dx * 0.004;
        graphGroup.rotation.x += dy * 0.003;
        lastX = e.clientX;
        lastY = e.clientY;
      });

      // Progressive background transformation on interaction
      threeRoot.addEventListener('pointerdown', ()=>{
        document.body.classList.add('bg-transition');
        setTimeout(()=>document.body.classList.remove('bg-transition'), 1200);
      });
    }
    
    // Fallback 2D visualization
    function createFallback3D(container) {
      const canvas = document.createElement('canvas');
      canvas.width = container.clientWidth;
      canvas.height = container.clientHeight;
      canvas.style.width = '100%';
      canvas.style.height = '100%';
      container.appendChild(canvas);
      
      const ctx = canvas.getContext('2d');
      let animationFrame = 0;
      
      function drawFallback() {
        animationFrame += 0.02;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // Gradient background
        const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
        gradient.addColorStop(0, 'rgba(0, 234, 255, 0.1)');
        gradient.addColorStop(1, 'rgba(255, 68, 68, 0.1)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Draw animated lines
        ctx.strokeStyle = '#00eaff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        
        const points = 24;
        for (let i = 0; i < points; i++) {
          const x = (i / (points - 1)) * canvas.width;
          const baseY = canvas.height * 0.5;
          const y = baseY + Math.sin(i * 0.5 + animationFrame) * 80 + Math.cos(i * 0.3 + animationFrame * 0.7) * 40;
          
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        ctx.stroke();
        
        // Draw points
        ctx.fillStyle = '#00eaff';
        for (let i = 0; i < points; i++) {
          const x = (i / (points - 1)) * canvas.width;
          const baseY = canvas.height * 0.5;
          const y = baseY + Math.sin(i * 0.5 + animationFrame) * 80 + Math.cos(i * 0.3 + animationFrame * 0.7) * 40;
          
          ctx.beginPath();
          ctx.arc(x, y, 4, 0, Math.PI * 2);
          ctx.fill();
        }
        
        // Add text overlay
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Live Reputation Tracking (2D Fallback)', canvas.width / 2, 30);
        
        requestAnimationFrame(drawFallback);
      }
      
      drawFallback();
      
      // Handle resize
      window.addEventListener('resize', () => {
        canvas.width = container.clientWidth;
        canvas.height = container.clientHeight;
      });
    }

    // Cumulative Summary Chart with fallback
    let summaryChart;
    
    function generateCumulativeData() {
      const days = 90; // 90 days of data
      const dates = [];
      const muskCumulative = [];
      const trumpCumulative = [];
      
      let muskSum = 0;
      let trumpSum = 0;
      
      for (let i = days - 1; i >= 0; i--) {
        const date = new Date();
        date.setDate(date.getDate() - i);
        dates.push(date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }));
        
        // Simulate daily scores with realistic trends
        const muskDaily = 70 + Math.sin(i * 0.1) * 10 + (Math.random() - 0.5) * 8;
        const trumpDaily = 65 + Math.cos(i * 0.08) * 12 + (Math.random() - 0.5) * 10;
        
        muskSum += muskDaily;
        trumpSum += trumpDaily;
        
        muskCumulative.push(muskSum / (days - i));
        trumpCumulative.push(trumpSum / (days - i));
      }
      
      return { dates, muskCumulative, trumpCumulative };
    }
    
    function initSummaryChart() {
      const canvas = document.getElementById('summaryChart');
      
      if (typeof Chart === 'undefined') {
        console.log('Chart.js not available, using canvas fallback');
        createFallbackChart(canvas);
        return;
      }
      
      const ctx = canvas.getContext('2d');
      const data = generateCumulativeData();
      
      // Create gradients
      const muskGradient = ctx.createLinearGradient(0, 0, 0, 300);
      muskGradient.addColorStop(0, 'rgba(59, 130, 246, 0.4)');
      muskGradient.addColorStop(1, 'rgba(59, 130, 246, 0.0)');
      
      const trumpGradient = ctx.createLinearGradient(0, 0, 0, 300);
      trumpGradient.addColorStop(0, 'rgba(239, 68, 68, 0.4)');
      trumpGradient.addColorStop(1, 'rgba(239, 68, 68, 0.0)');
      
      summaryChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: data.dates,
          datasets: [
            {
              label: 'Musk Cumulative Average',
              data: data.muskCumulative,
              borderColor: '#3b82f6',
              backgroundColor: muskGradient,
              borderWidth: 3,
              fill: true,
              tension: 0.4,
              pointRadius: 0,
              pointHoverRadius: 6
            },
            {
              label: 'Trump Cumulative Average',
              data: data.trumpCumulative,
              borderColor: '#ef4444',
              backgroundColor: trumpGradient,
              borderWidth: 3,
              fill: true,
              tension: 0.4,
              pointRadius: 0,
              pointHoverRadius: 6
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            intersect: false,
            mode: 'index'
          },
          plugins: {
            legend: {
              position: 'top',
              labels: {
                usePointStyle: true,
                color: '#fff',
                font: { size: 12, weight: '600' },
                padding: 15
              }
            },
            tooltip: {
              backgroundColor: 'rgba(0, 0, 0, 0.8)',
              titleColor: '#fff',
              bodyColor: '#fff',
              borderColor: 'rgba(255, 255, 255, 0.2)',
              borderWidth: 1,
              cornerRadius: 8,
              callbacks: {
                label: function(context) {
                  return `${context.dataset.label}: ${context.parsed.y.toFixed(1)}`;
                }
              }
            }
          },
          scales: {
            x: {
              display: true,
              grid: { display: false },
              ticks: {
                color: '#fff',
                maxTicksLimit: 8,
                font: { size: 10 }
              }
            },
            y: {
              display: true,
              min: 40,
              max: 85,
              grid: { color: 'rgba(255, 255, 255, 0.1)' },
              ticks: {
                color: '#fff',
                font: { size: 10 }
              }
            }
          }
        }
      });
    }
    
    // Fallback chart using canvas
    function createFallbackChart(canvas) {
      const ctx = canvas.getContext('2d');
      const data = generateCumulativeData();
      let animationProgress = 0;
      
      function drawChart() {
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        canvas.width = width;
        canvas.height = height;
        
        ctx.clearRect(0, 0, width, height);
        
        // Background
        ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
        ctx.fillRect(0, 0, width, height);
        
        // Chart area
        const padding = 40;
        const chartWidth = width - padding * 2;
        const chartHeight = height - padding * 2;
        
        // Data points
        const maxPoints = Math.min(data.muskCumulative.length, Math.floor(animationProgress * data.muskCumulative.length));
        
        if (maxPoints > 1) {
          // Draw Musk line
          ctx.strokeStyle = '#3b82f6';
          ctx.lineWidth = 3;
          ctx.beginPath();
          
          for (let i = 0; i < maxPoints; i++) {
            const x = padding + (i / (data.muskCumulative.length - 1)) * chartWidth;
            const y = padding + chartHeight - ((data.muskCumulative[i] - 40) / 45) * chartHeight;
            
            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          ctx.stroke();
          
          // Draw Trump line
          ctx.strokeStyle = '#ef4444';
          ctx.beginPath();
          
          for (let i = 0; i < maxPoints; i++) {
            const x = padding + (i / (data.trumpCumulative.length - 1)) * chartWidth;
            const y = padding + chartHeight - ((data.trumpCumulative[i] - 40) / 45) * chartHeight;
            
            if (i === 0) {
              ctx.moveTo(x, y);
            } else {
              ctx.lineTo(x, y);
            }
          }
          ctx.stroke();
        }
        
        // Labels
        ctx.fillStyle = '#fff';
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('Cumulative Reputation Scores (90 Days)', width / 2, 25);
        
        // Legend
        ctx.font = '12px Arial';
        ctx.textAlign = 'left';
        ctx.fillStyle = '#3b82f6';
        ctx.fillRect(padding, height - 25, 12, 12);
        ctx.fillStyle = '#fff';
        ctx.fillText('Musk', padding + 20, height - 15);
        
        ctx.fillStyle = '#ef4444';
        ctx.fillRect(padding + 80, height - 25, 12, 12);
        ctx.fillStyle = '#fff';
        ctx.fillText('Trump', padding + 100, height - 15);
        
        // Animation
        if (animationProgress < 1) {
          animationProgress += 0.02;
          requestAnimationFrame(drawChart);
        }
      }
      
      drawChart();
      
      // Handle resize
      window.addEventListener('resize', () => {
        drawChart();
      });
    }
    
    // AI Source Status Monitoring with backend integration
    async function updateSourcesStatus() {
      const sources = [
        { name: 'API Endpoints', status: 'checking', lastUpdate: 'Checking...' },
        { name: 'Database Tables', status: 'active', lastUpdate: '2 min ago' },
        { name: 'Event Logs', status: 'active', lastUpdate: '1 min ago' },
        { name: 'Social Media Feeds', status: 'active', lastUpdate: '30 sec ago' },
        { name: 'AI Sentiment Engine', status: 'active', lastUpdate: '5 sec ago' }
      ];
      
      try {
        // Test backend connectivity
        const healthResponse = await fetch('http://localhost:5000/health');
        const reputationResponse = await fetch('http://localhost:5000/api/reputation');
        
        const isBackendOnline = healthResponse.ok && reputationResponse.ok;
        
        // Update source statuses based on backend availability
        sources[0].status = isBackendOnline ? 'active' : 'offline';
        sources[0].lastUpdate = isBackendOnline ? 'Just now' : 'Connection failed';
        sources[1].status = isBackendOnline ? 'active' : 'warning';
        
        if (isBackendOnline) {
          const data = await reputationResponse.json();
          // Update stats with real data
          updateStatsWithRealData(data);
        }
        
      } catch (error) {
        console.log('Backend offline - using mock data');
        sources[0].status = 'offline';
        sources[0].lastUpdate = 'Offline';
        sources[1].status = 'warning';
      }
      
      // Update sources display with enhanced styling
      const sourcesList = document.getElementById('sourcesList');
      if (sourcesList) {
        sourcesList.innerHTML = sources.map(source => {
          const statusColor = source.status === 'active' ? '#4ade80' : 
                            source.status === 'warning' ? '#fbbf24' : '#ef4444';
          const statusText = source.status === 'active' ? '‚óè' : 
                           source.status === 'warning' ? '‚ö†' : '‚óè';
          
          return `
            <li>
              <div class="source-name">${source.name} 
                <span style="float: right; font-size: 0.9em; color: ${statusColor}">
                  ${statusText}
                </span>
              </div>
              <div class="source-details">Last update: ${source.lastUpdate}</div>
            </li>
          `;
        }).join('');
      }
    }
    
    // Update statistics with real backend data
    function updateStatsWithRealData(data) {
      if (data && data.data) {
        document.getElementById('avgMuskScore').textContent = data.data.musk.score.toFixed(1);
        document.getElementById('avgTrumpScore').textContent = data.data.trump.score.toFixed(1);
        
        // Update timestamp-based metrics
        const totalPoints = Math.floor(Date.now() / 30000); // Simulated data points every 30s
        document.getElementById('totalDataPoints').textContent = totalPoints.toLocaleString();
      }
    }
    
    // Enhanced dashboard initialization
    function initDashboard() {
      // Initialize 3D visualization
      init3DGraph();
      
      // Initialize charts
      setTimeout(() => {
        initSummaryChart();
      }, 500);
      
      // Update sources status
      updateSourcesStatus();
      
      // Set up periodic updates for real-time data
      setInterval(updateSourcesStatus, 15000); // Update every 15 seconds
      
      // Performance monitoring
      console.log('Dashboard initialized with performance optimizations');
      
      // Add loading indicator removal
      setTimeout(() => {
        document.body.classList.add('loaded');
      }, 1000);
    }
    
    // Start enhanced dashboard when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initDashboard);
    } else {
      initDashboard();
    }
  </script>
</body>
</html>
